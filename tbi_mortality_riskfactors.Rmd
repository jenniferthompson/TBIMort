---
title: Baseline and In-Hospital Risk Factors for Mortality and Other Outcomes among
  TBI Patients
author: 'Jennifer Thompson, MPH; Supervisor: Rameela Chandrasekhar, PhD'
date: '`r format(Sys.time(), "%B %d %Y")`'
output:
  html_notebook:
    theme: yeti
    code_folding: hide
    toc: yes
    toc_depth: 4
    toc_float: yes
  html_document:
    toc: yes
    toc_depth: 2
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: 2
abstract: The following analyses examine baseline and in-hospital risk factors for
  in-hospital mortality, in-hospital and discharge characteristics, and long-term
  mortality among a cohort of traumatic brain injury (TBI) patients with at least
  one day in the ICU.
---

```{r knitr_setup, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, results='hide')
options(width = 200)
```

```{r setup, message = FALSE, results='hide'}
## Make indentation for Markdown tables easier
space.3 <- paste(rep("&nbsp;", 3), collapse = '')
space.6 <- paste(rep("&nbsp;", 6), collapse = '')
space.9 <- paste(rep("&nbsp;", 9), collapse = '')
space.12 <- paste(rep("&nbsp;", 12), collapse = '')
space.15 <- paste(rep("&nbsp;", 15), collapse = '')

## Load libraries
library(captioner)
library(tidyverse)
library(pander)
library(corrplot)
library(rms)
library(plotly)
library(viridis)
library(mice)
library(htmltools)
library(metricsgraphics)

## Home directory (if on Mac, assumes connected to desktop via Samba)
if(Sys.info()['sysname'] == 'Darwin'){
  home.dir <- '/Volumes'
} else{
  home.dir <- '/home'
}

## -- Functions for general use --------------------------------------------------------------------
library(JTHelpers)

## Column headers for rms_model_results() tables for different kinds of model fits
cph.results.headers <-
  c('Covariate', 'Reference', 'Comparison', 'HR (95% CI)', 'Chi-square', 'df', 'P')

## Calculate what % (N) of records are missing in a given data set
## For a single variable: returns a vector with N, %, and formatted string including both
missingVariable <- function(vname, df){
  nmiss <- sum(is.na(df[,vname]))
  pctmiss <- (nmiss / nrow(df))*100
  pctmiss <- ifelse(pctmiss < 1 & nmiss > 0, round(pctmiss, 2), round(pctmiss, 0))
  
  c('nmiss' = nmiss,
    'pctmiss' = pctmiss,
    '% (N)' = paste0(pctmiss, '% (', format(nmiss, big.mark = ','), ')'))
}

## For a data frame: returns a data frame with variable name, N, %, and formatted strings
missingInDataFrame <- function(df, ## data frame for which to get missingness
                               ignore.vars = c('mrn', 'event', 'study.day')){
                               ## ignore these variables (typically, ID and time variables)
  tmp <- as.data.frame(do.call(rbind,
                               lapply(setdiff(names(df), ignore.vars), FUN = function(vname){
                                 c("Variable" = vname, missingVariable(vname, df))
                               })))
  tmp$nmiss <- as.numeric(as.character(tmp$nmiss))
  tmp$pctmiss <- as.numeric(as.character(tmp$pctmiss))
  return(tmp)
}


## -- Set up figure, table numbering using the captioner package -----------------------------------
table_nums <- captioner(prefix = 'Table')
table_nums(name = 'consort', caption = 'Cohort Inclusion and Exclusion')
table_nums(name = 'descstats_oneobs',
           caption = 'Baseline, In-Hospital, & Discharge Characteristics')
table_nums(name = 'descstats_daily', caption = 'Daily In-Hospital Characteristics')
table_nums(name = 'clinical_imputation',
           caption = 'Missingness among Daily Variables Imputed by Rule')
table_nums(name = 'mort_inhosp_missing_baseline',
           caption = 'Patients Excluded from In-Hospital Mortality Model due to Missing Baseline Data')
table_nums(name = 'mort_inhosp_missing_daily',
           caption = 'Patient-Days Requiring Imputation for In-Hospital Mortality Model')
table_nums(name = 'mort_inhosp_results', caption = 'Model Results Summary, In-Hospital Mortality')
table_nums(name = 'mort_3yr_missing_baseline',
           caption = 'Patients Excluded from Three-Year Mortality Model due to Missing Baseline Data')
table_nums(name = 'mort_3yr_missing_daily',
           caption = 'Patient-Days Requiring Imputation for Three-Year Mortality Model')
table_nums(name = 'mort_3yr_results', caption = 'Model Results Summary, Three-Year Mortality')
table_nums("delsummary_missing",
           caption = "Missingness Among Baseline Covariates and Delirium Summary Outcomes")
table_nums(name = 'deldays_results', caption = 'Model Results Summary, Delirium Duration')

table_nums(name = 'package_info', caption = 'R Packages Loaded')

figure_nums <- captioner(prefix = 'Figure')
figure_nums(name = 'dailydrughist',
            caption = 'Daily Drug Doses and Blood Product among Analysis Cohort')
figure_nums(name = 'mort_inhosp_zph', 'Proportional Hazards Assumption, In-Hospital Mortality')
figure_nums(name = 'mort_inhosp_figures', 'Hazard Ratios and 95% CIs, In-Hospital Mortality')
figure_nums(name = 'mort_3yr_zph', 'Proportional Hazards Assumption, Three-Year Mortality')
figure_nums(name = 'mort_3yr_figures', 'Hazard Ratios and 95% CIs, Three-Year Mortality')
figure_nums(name = 'deldays_figures', 'Adjusted Counts and 95% CIs, Delirium Days')

## -- Load analysis data sets, additional data management ------------------------------------------
load('AnalysisData/tbi_datasets.Rdata')

## Shorten long categories of factor variables
levels(tbi.oneobs$cpr.yn) <- c('No', 'Yes')
levels(tbi.oneobs$pt.marshall) <- gsub('Marshall Class ', '', levels(tbi.oneobs$pt.marshall))

## New variable with some levels of discharge disposition combined d/t small N
tbi.oneobs$disposition.comb <-
  with(tbi.oneobs, factor(ifelse(disposition.coded == 'Death in hospital', NA,
                          ifelse(disposition.coded %in% c('Discharged home',
                                                          'Psych unit',
                                                          'Jail or prison'), 1,
                          ifelse(disposition.coded == 'Inpatient rehab', 2,
                          ifelse(disposition.coded %in%
                                   c('LTAC',
                                     'Nursing care (including SNF and nursing home)',
                                     'Transfer to other hospital',
                                     'Hospice'), 3, NA)))),
                          levels = 1:3,
                          labels = c('Discharged to home, psych or prison',
                                     'Inpatient rehab',
                                     'Long-term care or hospice')))
label(tbi.oneobs$disposition.comb) <- 'Discharge disposition among survivors'

## Combine Marshall class IV with class III d/t small N (only 6 survivors in class IV)
tbi.oneobs$marshall.comb <- with(tbi.oneobs, factor(ifelse(pt.marshall == 'I', 1,
                                                    ifelse(pt.marshall == 'II', 2,
                                                    ifelse(pt.marshall %in% c('III', 'IV'), 3,
                                                    ifelse(pt.marshall == 'V/VI', 4, NA)))),
                                                    levels = 1:4,
                                                    labels = c('I', 'II', 'III/IV', 'V/VI')))
label(tbi.oneobs$marshall.comb) <- 'Marshall class, III/IV combined'

## Combine non-RBC blood products into a dichotomous received/not received variable
tbi.daily$any.plasmaplt <-
  factor(ifelse(rowSums(tbi.daily[,c(paste0('units.', c('cryo', 'plasma', 'platelets')))] > 0) > 0,
                2, 1),
         levels = 1:2, labels = c('None', 'At least one'))
label(tbi.daily$any.plasmaplt) <- '24h plasma and/or platelets'

## Dichotomous variables for PRBC, all drugs
any.drug <- function(x){ factor(ifelse(x == 0, 1, 2), levels = 1:2, labels = c('None', 'Some')) }

tbi.daily <- tbi.daily %>%
  mutate(any.prbc = factor(ifelse(units.prbc > 0, 2, 1),
                           levels = 1:2, labels = c('None', 'At least some')),
         any.antipsyc = any.drug(tot.antipsyc),
         any.benzo = any.drug(tot.benzo),
         any.betablock = any.drug(tot.betablock),
         any.clonid = any.drug(tot.clonid),
         any.dex = any.drug(tot.dex),
         any.opioid = any.drug(tot.opioid),
         any.pento = any.drug(tot.pento),
         any.propofol = any.drug(tot.propofol),
         ## Combined dichotomous variable for alpha-2 agonists (dex/clonidine)
         any.alpha2 = factor(as.numeric(any.dex == 'Some' | any.clonid == 'Some') + 1,
                             levels = 1:2, labels = c('Neither', 'One or both')))

label(tbi.daily$any.prbc) <- '24h PRBC'
label(tbi.daily$any.antipsyc) <- '24h antipsychotics, y/n'
label(tbi.daily$any.benzo) <- '24h benzodiazepines, y/n'
label(tbi.daily$any.betablock) <- '24h beta-blockers, y/n'
label(tbi.daily$any.clonid) <- '24h clonidine, y/n'
label(tbi.daily$any.dex) <- '24h dexmedetomidine, y/n'
label(tbi.daily$any.opioid) <- '24h opioids, y/n'
label(tbi.daily$any.pento) <- '24h pentobarbital, y/n'
label(tbi.daily$any.propofol) <- '24h propofol, y/n'
label(tbi.daily$any.alpha2) <- '24h alpha-2 agonists (clonidine/dex)'

## Shorten factor levels
levels(tbi.daily$max.icp.dich) <- c('Normal', 'Abnormal')

## -- Create analysis data sets including only ICU patients ----------------------------------------
## Patients with an ICU LOS of at least 1 day, admitted with blunt trauma
icu.pts <- unique(filter(tbi.oneobs, !is.na(icu.los) & icu.los > 0 & pt.injury == 'Blunt')$mrn)

## Filter daily data
tbi.daily.icu <- filter(tbi.daily, mrn %in% icu.pts)

## How many patients who would otherwise be included had no daily EMR data?
icu.nodaily.pts <- setdiff(icu.pts, unique(tbi.daily.icu$mrn))

## MRNs of all patients included in final analyses (>=1 ICU day, demographic + daily data)
pts.inc <- intersect(icu.pts, unique(tbi.daily.icu$mrn))

## Subset tbi.oneobs to only include pts.inc
tbi.oneobs.icu <- filter(tbi.oneobs, mrn %in% pts.inc)

## -- Patients who survived hospital stay, are eligible for 3-year mortality model -----------------
pts.inc.survived <- subset(tbi.oneobs.icu, hosp.death == 'No')$mrn

```

# Cohort Description

---

We originally collected electronic medical record data for `r length(unique(tbi.oneobs$mrn))`
patients aged 16 years or older admitted to VUMC between August 2006 and July 2012 with traumatic
brain injury (TBI) requiring hospitalization. TBI was classified based on ICD-9 diagnostic codes,
and includes concussion without intracranial hemorrhage. Code used to create analysis data sets from
raw EMR data can be found
[here](https://github.com/jenniferthompson/TBIMort/blob/master/tbimortality_datamgmt.R).

For these analyses, we focused on patients admitted to the ICU and who had blunt (vs penetrating)
trauma.

## CONSORT Information
`r table_nums('consort', display = 'cite')` describes how patients were included and
excluded from our broad cohort, with requirements for inclusion in **bold**. Patients included in
each specific analysis will be described in each section, beginning with this group of
`r length(pts.inc)`.

```{r create_consort_table}
## -- Calculate Ns for each group of patients included/excluded ------------------------------------
## Original number of TBI patients
n.alltbi <- length(unique(tbi.oneobs$mrn))

## Had penetrating vs blunt trauma
n.injuryna <- sum(tbi.oneobs$pt.injury == 'Missing', na.rm = TRUE)
n.penetrating <- sum(tbi.oneobs$pt.injury == 'Penetrating', na.rm = TRUE)
n.blunt <- sum(tbi.oneobs$pt.injury == 'Blunt', na.rm = TRUE)

## Blunt injury and had ICU LOS >= 1 day?
n.nolos <- sum(is.na(subset(tbi.oneobs, pt.injury == 'Blunt')$icu.los))
n.noicu <- with(subset(tbi.oneobs, pt.injury == 'Blunt'), sum(!is.na(icu.los) & icu.los == 0))
n.icu <- length(icu.pts)

## No daily data vs included in main analyses (meaning, at least one day of daily data)
n.nodaily <- length(icu.nodaily.pts)
n.included.main <- length(pts.inc)

## Create CONSORT table
consort.table <- data.frame(Patients = c('All TBI Patients',
                                         paste0(space.3, 'Missing injury type'),
                                         paste0(space.3, 'Penetrating injury'),
                                         paste0(space.3, '**Blunt injury**'),
                                         paste0(space.6, 'Missing ICU LOS data'),
                                         paste0(space.6, '0 days in ICU'),
                                         paste0(space.6, '**>=1 day in ICU**'),
                                         paste0(space.9, 'Missing daily EMR data'),
                                         paste0(space.9, '**Eligible for inclusion**')),
                            N = c(n.alltbi, n.injuryna, n.penetrating, paste0('**', n.blunt, '**'),
                                  n.nolos, n.noicu, paste0('**', n.icu, '**'), n.nodaily,
                                  paste0('**', n.included.main, '**')))

```

#### `r table_nums('consort')`
```{r print_consort_table, results = 'asis'}
pandoc.table(consort.table, justify = c('left', 'right'))

```

## Descriptive Statistics for Baseline, Summary and Daily Characteristics
#### `r table_nums('descstats_oneobs')`
```{r print_descstats_oneobs, results = 'markup'}
html(summaryM(age + gender + race + insurance.code + iss + cpr.yn + pt.marshall + pt.cerebral +
                pt.epidural + pt.injury + vent.days + days.mental + days.del + days.coma + dcfd.14 +
                icu.los + los + hosp.death + disposition.coded + fim.total + died.3yr.adm ~ 1,
              data = tbi.oneobs.icu),
     exclude1 = FALSE, long = TRUE, npct = 'both', what = '%', digits = 2,
     prmsd = TRUE, brmsd = TRUE, rmarkdown = TRUE,
     msdsize = markupSpecs$html$smaller2,
     caption = 'Descriptive Statistics, All Eligible Patients')

```

#### `r table_nums('descstats_daily')`
```{r print_descstats_daily, results = 'markup'}
html(summaryM(mental.status + max.motor.imp + pupil.react.imp + min.glucose.imp +
                min.hemoglobin.imp + min.sodium.imp + max.icp.imp + max.icp.dich +
                sofa.nanormal.imp + any.benzo + tot.benzo + any.opioid + tot.opioid + any.propofol +
                tot.propofol + any.dex + tot.dex + any.clonid + tot.clonid + any.alpha2 +
                any.antipsyc + tot.antipsyc + any.betablock + tot.betablock + any.pento +
                tot.pento + any.plasmaplt + units.cryo + units.plasma + units.platelets +
                any.prbc + units.prbc ~ 1,
              data = tbi.daily.icu),
     exclude1 = FALSE, long = TRUE, npct = 'both', what = '%', digits = 2,
     prmsd = TRUE, brmsd = TRUE, rmarkdown = TRUE,
     msdsize = markupSpecs$html$smaller2,
     caption = 'Descriptive Statistics, All Eligible Patient-Days')

```

## Exploratory Analyses
```{r exploratory_datamgmt}
## -- Describe daily drug, blood product doses -----------------------------------------------------
## Raw doses for histograms
daily.drugs <- tbi.daily.icu %>%
  dplyr::select(mrn, study.day, tot.benzo.cube, tot.opioid.cube, tot.propofol.cube, tot.dex.cube,
         tot.antipsyc.cube, tot.betablock.cube, tot.pento.cube, tot.clonid.cube, units.cryo,
         units.plasma, units.platelets, units.prbc) %>%
  gather(key = drug.or.product, value = amount, tot.benzo.cube:units.prbc)

## Summary statistics for annotation
daily.drugs.summary <- daily.drugs %>%
  group_by(drug.or.product) %>%
  summarise(n.zero = sum(amount == 0),
            pct.zero = round(mean(amount == 0)*100, digits = 1),
            min.nonzero = round(min(amount[amount != 0]), 2),
            med.nonzero = round(median(amount[amount != 0]), 2),
            max.nonzero = round(max(amount[amount != 0]), 2)) %>%
  mutate(results.str = paste0('% (N) Zero: ', pct.zero, '% (', n.zero,
                              ')\nMedian (Range) among Non-Zero:\n',
                              med.nonzero, ' (', min.nonzero, ', ', max.nonzero, ')'))

```

To guide our choice of covariates in models with time-varying covariates, we plotted histograms and detailed summary statistics for all drug doses and blood products given on a daily basis (`r figure_nums('dailydrughist', display = 'cite')`).

#### `r figure_nums('dailydrughist')`
```{r print_exploratory, results = 'asis', fig.width=7, fig.height=10}
ggplot(data = daily.drugs, aes(x = amount)) +
  facet_wrap(~ drug.or.product, ncol = 2, scales = 'free_x') +
  geom_histogram() +
  geom_text(data = daily.drugs.summary, aes(label = results.str, x = max.nonzero),
            y = 30000, hjust = 1, vjust = 1, size = 3)

```

# Clinical Imputation Rules for Missing Data

---

As this is medical record data, there is a large amount of missingness: labs are not ordered unless
there is reason to order them, for example. We developed a set of clinical imputation rules to deal
with much of this missingness among our covariates.

Several daily variables were imputed by using the closest value within two days before or after the
missing value. If two values equidistant from the missing day were available, preference was given
to the earlier value. `r table_nums("clinical_imputation", display = 'cite')` shows the number of records originally missing for each of these variables; the number successfully imputed using this two-day rule; and the number which remain missing after the two-day rule was implemented.

```{r clinical_imp}
## -- For each covariate imputed via two-day rule, get N missing in original data, -----------------
## -- N successfully imputed, and N still missing after imputation ---------------------------------
clinical.imp.covars <- c('max.motor', 'pupil.react', 'min.glucose', 'min.hemoglobin', 'min.sodium',
                         'sofa.resp', 'sofa.cns', 'sofa.cv', 'sofa.coag', 'sofa.renal')

clinical.imp.npct.missing <- do.call(rbind,
                                     lapply(clinical.imp.covars, FUN = function(vname){
  vname.imp <- paste0(vname, '.imp')
  
  ## N, % missing in original data
  nmiss.org <- sum(is.na(tbi.daily.icu[,vname]))
  pctmiss.org <- round((nmiss.org / nrow(tbi.daily.icu))*100)
  
  ## N, % of missing imputed
  nimp <- sum(is.na(tbi.daily.icu[,vname]) & !is.na(tbi.daily.icu[,vname.imp]))
  pctimp <- round((nimp / nmiss.org)*100)
  
  ## N, % of patient-days still missing after imputation
  nmiss.imp <- sum(is.na(tbi.daily.icu[,vname.imp]))
  pctmiss.imp <- round((nmiss.imp / nrow(tbi.daily.icu))*100)
  
  c("% (N) Missing,\nOriginal Data" =
      paste0(pctmiss.org, '% (', format(nmiss.org, big.mark = ','), ')'),
    "% (N) of Missing\nValues Imputed" = paste0(pctimp, '% (', format(nimp, big.mark = ','), ')'),
    "% (N) Still Missing\nAfter Imputation" =
      paste0(pctmiss.imp, '% (', format(nmiss.imp, big.mark = ','), ')'))
}))

rownames(clinical.imp.npct.missing) <- clinical.imp.covars

## How many records had missing ICP / ICP > 120 in original data?
n.icpmiss <- sum(is.na(tbi.daily.icu$max.icp))
pct.icpmiss <- round((n.icpmiss / nrow(tbi.daily.icu))*100)
npct.icpmiss <- paste0(pct.icpmiss, '% (', format(n.icpmiss, big.mark = ','), ')')

n.icp120 <- sum(tbi.daily.icu$max.icp > 120, na.rm = TRUE)
pct.icp120 <- round((n.icp120 / nrow(tbi.daily.icu))*100, digits = 2)
npct.icp120 <- paste0(pct.icp120, '% (', format(n.icp120, big.mark = ','), ')')

```

#### `r table_nums("clinical_imputation")`
Percentages for original and post-imputation missingness are out of the `r nrow(tbi.daily.icu)` in-hospital patient-days among those patients eligible for inclusion in our analyses.

```{r print_clinical_imp, results = 'asis'}
panderOptions('table.emphasize.rownames', FALSE)
panderOptions('keep.line.breaks', TRUE)
pander(clinical.imp.npct.missing, keep.line.breaks = TRUE)

```

Additionally:

- The liver component of the SOFA score was considered to be normal if no bilirubin was measured.
- Missing maximum ICP was assumed to be normal, and assigned a random value from a uniform distribution ranging from 0 to 20 (normal range; imputed values were rounded, to result in integer scores). Maximum ICP > 120 was truncated to 120. In the original data, `r npct.icpmiss` records were missing ICP and assigned a random normal-range value, and `r npct.icp120` had ICP > 120.
- When calculating final full and modified SOFA scores, components which were still missing after
clinical imputation were assumed to be normal (component score = 0). For example, if a patient was hospitalized for five days and never had creatinine measured, that patient would be assumed to have no renal dysfunction during this hospitalization and would have SOFA renal scores of 0 on all five days (though the overall SOFA score would depend on the other components). This also means that any
patient-day with no SOFA component data has a SOFA score of 0.
- If no dose was recorded for medications or blood products on a given day, we assume the patient received no drug/product, and the dose is considered to be 0.
- If no maximum motor score was available on Days 00 - 02, the *baseline* maximum motor score was considered to be normal and assigned a value of 6.

There is still missing data after these imputation rules are implemented; for example, if a patient's glucose was never measured, there was never a value to carry forward or backward. Specific
amounts of missingness and strategies for handling it will be detailed separately for each analysis.

# Mortality Outcomes

---

To identify potential risk factors for both in-hospital and three-year mortality among this cohort,
we will use Cox proportional hazards regression with both baseline and time-dependent covariates.

## In-Hospital Mortality
### Model Covariates
We will include the following covariates in the in-hospital mortality model (reference levels for
categorical variables are listed first):

- Baseline
    - Age at admission
    - Gender *(`r paste(levels(tbi.oneobs.icu$gender), collapse = '; ')`)*
    - Insurance type *(`r paste(levels(tbi.oneobs.icu$insurance.code), collapse = '; ')`)*
    - Marshall Class equivalent *(`r paste(levels(tbi.oneobs.icu$marshall.comb), collapse = '; ')`)*
    - Cerebral subarachnoid hemorrhage (SAH) *(`r paste(levels(tbi.oneobs.icu$pt.cerebral.na), collapse = '; ')`)*
    - Injurity Severity Score (ISS)
    - CPR *(`r paste(levels(tbi.oneobs.icu$cpr.yn), collapse = '; ')`)*
- Daily In-Hospital (all per 24h)
    - Maximum motor score
    - Pupil reactivity *(`r paste(levels(tbi.daily.icu$pupil.react.imp), collapse = '; ')`)*
    - Minimum glucose
    - Minimum hemoglobin
    - Minimum sodium
    - Mental status *(`r paste(levels(tbi.daily.icu$mental.status), collapse = '; ')`)*
    - Modified SOFA score (excluding CNS component)
    - 24-hour doses of medications: all will be cube root transformed to mitigate the influence of extremely high values
        - Opioids (hydromorphone, morphine, hydrocodone, methadone, remifentanil, and fentanyl; converted to fentanyl equivalents); allowed to be nonlinear
        - Benzodiazepines (lorazepam, diazepam, alprazolam, clonazepine, and midazolam; all converted to midazolam equivalents); allowed to be nonlinear
        - Antipsychotics (olanzapine, quetiapine, risperidone, ziprasidone, and haloperidol; all converted to haloperidol equivalents); forced to be linear
        - Beta-blockers (propranolol, labetalol, esmolol, and metoprolol; all converted to metoprolol equivalents); allowed to be nonlinear
        - Propofol; forced to be linear
        - Clonidine; forced to be linear
        - Dexmedetomidine; had to dichotomize *(`r paste(levels(tbi.daily.icu$any.dex), collapse = '; ')`)* due to high proportion of 0 values and sparse non-zero values
    - 24-hour units of blood products:
        - PRBC *(`r paste(levels(tbi.daily.icu$any.prbc), collapse = '; ')`)*
        - Plasma, platelets, and/or cryo *(`r paste(levels(tbi.daily.icu$any.plasmaplt), collapse = '; ')`)*

The following covariates were considered for inclusion, but changed or excluded as follows:

- Pentobarbital dose was originally slated as a covariate, but because there was so little pentobarbital use in our cohort, this covariate would only create problems while adding essentially
no information. See `r figure_nums('dailydrughist', display = 'cite')`.
- Plasma, platelets, and cryo were originally slated to be included as continuous units given;
however, because so few of these products were used (see
`r figure_nums('dailydrughist', display = 'cite')`), these were combined into a dichotomous yes/no
variable. Similarly, we had to dichotomize PRBC into given vs not given, rather than using the actual units.

Due to the amount of missingness in our data but also the complexity of performing multiple
imputation with both baseline (time-constant) and daily (time-varying) covariates, we will include
in this model only eligible patients with complete baseline data, and will use multiple imputation
to handle missing daily data. Patient exclusions and missingness will be detailed below.

### Correlation between Continuous Covariates
```{r mort_cont_covars}
mortality.continuous.covars <- c('age', 'iss', 'vent.days', 'los',
                                 'max.motor.imp', 'min.glucose.imp', 'min.hemoglobin.imp',
                                 'min.sodium.imp', 'sofa.mod.nanormal.imp', 'tot.opioid.cube',
                                 'tot.benzo.cube', 'tot.antipsyc.cube', 'tot.betablock.cube',
                                 'tot.propofol.cube', 'tot.clonid.cube')
mortality.categorical.covars <- c('gender', 'insurance.code', 'marshall.comb', 'pt.cerebral.na',
                                  'cpr.yn', 'pupil.react.imp', 'mental.status', 'any.dex',
                                  'any.prbc', 'any.plasmaplt', 'disposition.comb')

mort.corr.data <- dplyr::select(tbi.oneobs.icu, mrn, one_of(mortality.continuous.covars)) %>%
  right_join(dplyr::select(tbi.daily.icu, mrn, one_of(mortality.continuous.covars)),
             by = 'mrn')

mort.inhosp.corr.data <- mort.corr.data %>%
  filter(mrn %in% pts.inc) %>%
  dplyr::select(-mrn, -vent.days, -los)

## Continuous vs continuous: Spearman correlations
corr.mort.inhosp <- cor(mort.inhosp.corr.data,
                        use = 'pairwise.complete.obs',
                        method = 'spearman')

```

```{r print_mort_inhosp_corr, results = 'asis'}
corrplot.mixed(corr.mort.inhosp,
               tl.cex = 0.5, title = 'In-Hospital Mortality', tl.col = 'black', mar = c(0, 0, 1, 0))

```

```{r mort_inhosp_missing}
## -- Lists of covariates for mortality models -----------------------------------------------------
mortality.baseline.covars <- c('age', 'gender', 'insurance.code', 'marshall.comb', 'pt.cerebral.na',
                               'iss', 'cpr.yn')
mortality.daily.covars <- c('max.motor.imp', 'pupil.react.imp', 'min.glucose.imp',
                            'min.hemoglobin.imp', 'min.sodium.imp', 'mental.status',
                            'sofa.mod.nanormal.imp', 'max.icp.imp', 'max.icp.dich',
                            'tot.opioid.cube', 'tot.benzo.cube', 'tot.antipsyc.cube',
                            'tot.betablock.cube', 'tot.propofol.cube', 'any.dex', 'tot.clonid.cube',
                            'any.prbc', 'any.plasmaplt')
mortality.3yr.covars <- c('disposition.comb', 'vent.days', 'los')

## How many patients are missing *any* of these baseline variables?
tbi.oneobs.icu$include.mort.inhosp <-
  rowSums(is.na(tbi.oneobs.icu[,mortality.baseline.covars])) == 0
n.exc.mort.inhosp <- sum(!tbi.oneobs.icu$include.mort.inhosp)

## MRNs of patients included in mortality models
pts.inc.mort.inhosp <- unique(subset(tbi.oneobs.icu, include.mort.inhosp)$mrn)

mort.inhosp.baseline.missing <-
  as.data.frame(do.call(rbind,
                        lapply(mortality.baseline.covars,
                               FUN = function(vname){
                                 nmiss <- sum(is.na(tbi.oneobs.icu[,vname]))
                                 pctall.miss <- round((nmiss / length(pts.inc))*100, 2)
                                 pctexc.miss <- round((nmiss / n.exc.mort.inhosp)*100, 0)
                                 c(nmiss, pctall.miss, pctexc.miss)
                               })))
mort.inhosp.baseline.missing <- cbind(mortality.baseline.covars, mort.inhosp.baseline.missing)
names(mort.inhosp.baseline.missing) <- c('Covariate',
                                         'N Missing Covariate',
                                         '% Eligible Patients',
                                         '% Excluded Patients')
mort.inhosp.baseline.missing <- mort.inhosp.baseline.missing[mort.inhosp.baseline.missing[,2] > 0,]
rownames(mort.inhosp.baseline.missing) <- NULL

## Describe missingness among patient-days included in in-hospital mortality model
mort.inhosp.daily.missing <- tbi.daily.icu %>%
  filter(mrn %in% pts.inc.mort.inhosp) %>%
  dplyr::select(one_of(mortality.daily.covars)) %>%
  missingInDataFrame() %>%
  filter(nmiss > 0)
rownames(mort.inhosp.daily.missing) <- NULL

```

### Patient Inclusion and Missing Data
Out of `r length(pts.inc)` patients eligible to be included in the in-hospital mortality model, `r n.exc.mort.inhosp` are missing one or more baseline covariates and will be excluded, leaving **`r length(pts.inc.mort.inhosp)`** patients included. `r table_nums("mort_inhosp_missing_baseline", display = 'cite')` details how many otherwise eligible patients are missing which baseline covariates.

#### `r table_nums("mort_inhosp_missing_baseline")`
```{r print_mort_inhosp_missing_baseline, results = 'asis'}
pandoc.table(mort.inhosp.baseline.missing, justify = c('left', 'right', 'right', 'right'))

```

Among those patients included, we did have some missing daily data which is handled using multiple
imputation. `r table_nums("mort_inhosp_missing_daily", display = 'cite')` details the percentage
and number of in-hospital patient-days among the `r length(pts.inc.mort.inhosp)` patients included
in the in-hospital mortality model with each variable missing.

#### `r table_nums("mort_inhosp_missing_daily")`
```{r print_mort_inhosp_missing_daily, results = 'asis'}
pandoc.table(mort.inhosp.daily.missing[,c('Variable', '% (N)')], justify = c('left', 'right'))

```

```{r mort_inhosp_datamgmt}
## Functions to set missing values to/from -9999 so they don't kicked out of
## create_countprocess_data()
set.na.9999 <- function(x){ ifelse(is.na(x), -9999, x) }
set.backto.na <- function(x){ ifelse(x == -9999, NA, x) }

## -- Create data set for in-hospital mortality model ----------------------------------------------
## Baseline information
base.mort.inhosp <- tbi.oneobs.icu %>%
  filter(include.mort.inhosp) %>%
  dplyr::select(mrn, age, gender, insurance.code, iss, cpr.yn, marshall.comb, pt.cerebral.na,
                hosp.death, time.death.dc)

## Daily data
daily.mort.inhosp.org <- tbi.daily.icu %>%
  filter(mrn %in% pts.inc.mort.inhosp) %>%
  ## We have missingness for lab values, mental status, pupil reactivity, max motor. By default,
  ## function for time-varying data sets will delete any row with missing data; we do not want this,
  ## because we want to impute missing values later. Temporarily set all missings to -9999 (this
  ## will make factors numeric; will need to fix later).
  mutate(max.motor.imp = set.na.9999(max.motor.imp),
         pupil.react.imp = set.na.9999(as.numeric(pupil.react.imp)),
         min.glucose.imp = set.na.9999(min.glucose.imp),
         min.hemoglobin.imp = set.na.9999(min.hemoglobin.imp),
         min.sodium.imp = set.na.9999(min.sodium.imp),
         mental.status = set.na.9999(as.numeric(mental.status))) %>%
  dplyr::select(mrn, study.day, max.motor.imp, pupil.react.imp, min.glucose.imp, min.hemoglobin.imp,
                min.sodium.imp, mental.status, sofa.mod.nanormal.imp, max.icp.imp, max.icp.dich,
                tot.opioid.cube, tot.benzo.cube, tot.antipsyc.cube, tot.betablock.cube,
                tot.propofol.cube, any.dex, tot.clonid.cube, any.prbc, any.plasmaplt)

## Create beginning time-varying data set
tv.mort.inhosp <- create_countprocess_data(org.data = daily.mort.inhosp.org,
                                           id.var = 'mrn',
                                           record.var = 'study.day',
                                           time.var = 'time.death.dc',
                                           event.var = 'hosp.death',
                                           event.string = 'Yes',
                                           data.set = tbi.oneobs.icu,
                                           out.strings = c('Alive through today', 'Died today'))

modeldata.mort.inhosp <- tv.mort.inhosp %>%
  ## Replace -9999s with NAs, refactor applicable variables
  mutate(max.motor.imp = set.backto.na(max.motor.imp),
         pupil.react.imp = factor(set.backto.na(pupil.react.imp),
                                  levels = 1:3, labels = levels(tbi.daily$pupil.react.imp)),
         min.glucose.imp = set.backto.na(min.glucose.imp),
         min.hemoglobin.imp = set.backto.na(min.hemoglobin.imp),
         min.sodium.imp = set.backto.na(min.sodium.imp),
         mental.status = factor(set.backto.na(mental.status),
                                levels = 1:3, labels = levels(tbi.daily$mental.status))) %>%
  ## Add on baseline variables
  left_join(base.mort.inhosp, ., by = 'mrn')

## For some reason, labels for some variables are not preserved. Add them again. Sigh.
label(modeldata.mort.inhosp$max.motor.imp) <- label(tbi.daily$max.motor.imp)
label(modeldata.mort.inhosp$pupil.react.imp) <- label(tbi.daily$pupil.react.imp)
label(modeldata.mort.inhosp$min.glucose.imp) <- label(tbi.daily$min.glucose.imp)
label(modeldata.mort.inhosp$min.hemoglobin.imp) <- label(tbi.daily$min.hemoglobin.imp)
label(modeldata.mort.inhosp$min.sodium.imp) <- label(tbi.daily$min.sodium.imp)
label(modeldata.mort.inhosp$mental.status) <- label(tbi.daily$mental.status)
label(modeldata.mort.inhosp$max.icp.dich) <- label(tbi.daily$max.icp.dich)
label(modeldata.mort.inhosp$any.dex) <- label(tbi.daily$any.dex)
label(modeldata.mort.inhosp$any.prbc) <- label(tbi.daily$any.prbc)
label(modeldata.mort.inhosp$any.plasmaplt) <- label(tbi.daily$any.plasmaplt)
## Shorten super long label for modified SOFA
label(modeldata.mort.inhosp$sofa.mod.nanormal.imp) <- 'Modified SOFA (missing comp. = 0)'

dd.inhosp <- datadist(modeldata.mort.inhosp, adjto.cat = 'first')
options(datadist = 'dd.inhosp')

```

### Redundancy Analysis
To see if any of the covariates in our in-hospital mortality model are nearly fully explained by the
others, we performed a redundancy analysis. Adjusted R^2^ values for each covariate are shown below.

```{r mort_inhosp_redun, results = 'markup'}
redun.mort.inhosp <- redun(~ age + gender + insurance.code + iss + cpr.yn + marshall.comb +
                             pt.cerebral.na + I(max.motor.imp) + pupil.react.imp + min.glucose.imp +
                             min.hemoglobin.imp + min.sodium.imp + mental.status +
                             sofa.mod.nanormal.imp + tot.opioid.cube +
                             tot.benzo.cube + I(tot.antipsyc.cube) + tot.betablock.cube +
                             I(tot.propofol.cube) + any.dex + I(tot.clonid.cube) + any.prbc +
                             any.plasmaplt,
                           data = modeldata.mort.inhosp, type = 'adjusted', nk = 4, allcat = TRUE)

highr2.mort.inhosp <- which.max(redun.mort.inhosp$rsq1)

round(redun.mort.inhosp$rsq1, 2)

```

The highest adjusted R^2^ value is `r round(redun.mort.inhosp$rsq1[highr2.mort.inhosp], 2)` (`r names(redun.mort.inhosp$rsq1[highr2.mort.inhosp])`), indicating that there are no redundant
variables. All covariates will be included as specified above.

```{r mort_inhosp_fitmod}
## -- Imputation for in-hospital mortality ---------------------------------------------------------
set.seed(56)
areg.mort.inhosp <- aregImpute(~ age + gender + insurance.code + iss + cpr.yn + marshall.comb +
                                 pt.cerebral.na + hosp.death + I(max.motor.imp) + pupil.react.imp +
                                 min.glucose.imp + min.hemoglobin.imp + min.sodium.imp +
                                 mental.status + sofa.mod.nanormal.imp + max.icp.dich +
                                 tot.opioid.cube + tot.benzo.cube + tot.antipsyc.cube +
                                 tot.betablock.cube + tot.propofol.cube + any.dex +
                                 tot.clonid.cube + any.prbc + any.plasmaplt + start.day,
                               data = modeldata.mort.inhosp,
                               n.impute = 5, burnin = 3)

## -- Fit model for in-hospital mortality ----------------------------------------------------------
Surv.mort.inhosp <- with(modeldata.mort.inhosp, Surv(time = start.day,
                                                     time2 = stop.day,
                                                     event = as.numeric(died)))

mod.mort.inhosp <- fit.mult.impute(Surv.mort.inhosp ~ rcs(age, 4) + gender + insurance.code +
                                     rcs(iss, 4) + cpr.yn + marshall.comb + pt.cerebral.na +
                                     max.motor.imp + pupil.react.imp + rcs(min.glucose.imp, 4) +
                                     rcs(min.hemoglobin.imp, 4) + rcs(min.sodium.imp, 4) +
                                     mental.status + rcs(sofa.mod.nanormal.imp, 4) +
                                     ## Drug doses with enough variability to include w/ splines
                                     rcs(tot.opioid.cube, 4) + rcs(tot.benzo.cube, 4) +
                                     rcs(tot.betablock.cube, 4) +
                                     ## 3 drugs have too many 0s + otherwise sparse data,
                                     ## can't fit splines
                                     tot.antipsyc.cube + tot.propofol.cube + tot.clonid.cube +
                                     ## Dex and blood products have too many 0s + wide range;
                                     ## dichotomize
                                     any.dex + any.prbc + any.plasmaplt,
                                   fitter = cph,
                                   xtrans = areg.mort.inhosp,
                                   data = modeldata.mort.inhosp,
                                   x = TRUE, y = TRUE)

```

### Model Assumptions

We checked the proportional hazards assumption graphically, looking at the time-dependent coefficient (beta(t)) over time for each model coefficient (code can be shown below).

```{r mort_inhosp_checkph, results='hide'}
## -- Check proportional hazard assumption ---------------------------------------------------------
zph.mort.inhosp <- cox.zph(mod.mort.inhosp, transform = 'log')

par(mfrow = c(1, 2))
plot(zph.mort.inhosp, col = 'red', lwd = 2)
abline(v = 0, lty = 2, col = 'gray')
par(mfrow = c(1, 1))

## Text for when figure is included:
# `r figure_nums('mort_inhosp_zph', display = 'cite')` graphically examines the proportional hazards
# assumption (that beta(t) is roughly constant over time; in other words, we want to see flat lines).
# 
# #### `r figure_nums('mort_inhosp_zph')`

```

We do not show the figures here to conserve space, but the proportional hazards
assumption was generally satisfied, though it did get understandably wobbly when data was very
sparse (longest followup times).

### Model Results
`r table_nums('mort_inhosp_results', display = 'cite')` presents a summary of results from the
in-hospital mortality model. Hazard ratios indicate a comparison between the "comparison" vs the "reference" columns, holding all other covariates at the median or reference category. For example,
a patient who was `r round(dd.inhosp$limits$age[3])` years old at the time of injury has about `r round(summary(mod.mort.inhosp, age = c(dd.inhosp$limits$age[1], dd.inhosp$limits$age[3]), est.all = FALSE)[2, 'Effect'], 1)` times the hazard of in-hospital death at any time point compared to a patient who was `r round(dd.inhosp$limits$age[1])` years old, assuming all other covariates are equal. Where possible, the reference and comparison values for continuous variables are the 25th and 75th percentiles, respectively; for variables where these quantities are the same (eg, several drug doses), these values are the minimum and maximum.

**Please note** that while p-values reflect the entire association of each covariate with our
outcome, hazard ratios are only valid for the comparisons listed: For continuous covariates which are allowed to have a nonlinear association with mortality, the hazard ratios depend on the two values we choose; for categorical covariates with more than two categories, the hazard ratios depend on the reference level chosen. More detailed hazard ratios are displayed in `r figure_nums('mort_inhosp_figures', display = 'cite')`.

#### `r table_nums('mort_inhosp_results')`
```{r mort_inhosp_results}
results.mort.inhosp <- rms_model_results(mod.mort.inhosp,
                                         labeldf = modeldata.mort.inhosp,
                                         printFormat = 'markdown')
names(results.mort.inhosp) <- cph.results.headers

```

```{r print_mort_inhosp_results, results = 'asis'}
pandoc.table(results.mort.inhosp, justify = 'lrrrrrr', style = 'rmarkdown', split.tables = 800)
```

#### `r figure_nums('mort_inhosp_figures')`
For numeric variables, all hazard ratios are for comparison to the median, our best "typical" value;
comparison values are the 10th, 25th, 75th, and 90th percentiles by default, though in some cases
(drug doses, for example), some of these percentiles are the same. For categorical variables, the
reference level is the lefthand level.

```{r mort_inhosp_figures}
## -- Get data frame of all HRs for all covariates -------------------------------------------------
## Get all unique variables used in model fit
vars.mort.inhosp <- unique(gsub("'+|=.+$", "", names(mod.mort.inhosp$coefficients)))

hrs.mort.inhosp <- bind_rows(lapply(vars.mort.inhosp,
                                    FUN = rms_calc_comparisons,
                                    rmsObj = mod.mort.inhosp,
                                    getRatios = TRUE,
                                    df = modeldata.mort.inhosp))

## -- Add variable *labels* ------------------------------------------------------------------------
hrs.mort.inhosp.labels <- as.data.frame(do.call(rbind,
                                                lapply(vars.mort.inhosp, FUN = function(v){
                                                  c('variable' = v,
                                                    'varlabel' = label(modeldata.mort.inhosp[,v]))
                                                })))
hrs.mort.inhosp <- hrs.mort.inhosp %>%
  left_join(hrs.mort.inhosp.labels, by = 'variable') %>%
  left_join(dplyr::select(results.mort.inhosp, Covariate, P),
            by = c("varlabel" = "Covariate"))

## -- Create properly ordered factor levels --------------------------------------------------------
hrs.mort.inhosp.flevels <-
  ## Get all unique factor levels + whether they are reference
  unique(subset(hrs.mort.inhosp, select = c(comp.c, is.ref))) %>%
  ## Create variables by which to order: numeric/NA, then for character, whether reference
  ## (numeric levels will always be ordered by numeric value, regardless of reference)
  mutate(level.num = as.numeric(as.character(comp.c)),
         is.ref.factor = ifelse(!is.na(level.num), FALSE, is.ref)) %>%
  ## Only need original, new reference indicator, and numeric
  dplyr::select(comp.c, is.ref.factor, level.num) %>%
  ## Take only unique: no need for multiple 0 levels, for example
  unique() %>%
  ## Sort all possible levels by 1. numeric values in order, 2. all reference levels,
  ## 3. all other character levels
  arrange(level.num, desc(is.ref.factor)) %>%
  ## Give each unique value a numeric value
  mutate(flevel.num = 1:nrow(.))

## Merge numeric values onto original data set, create final factor variable
hrs.mort.inhosp <- hrs.mort.inhosp %>%
  left_join(dplyr::select(hrs.mort.inhosp.flevels, comp.c, flevel.num),
            by = c('comp.c')) %>%
  mutate(flevel = factor(flevel.num, labels = hrs.mort.inhosp.flevels$comp.c),
         varlabel.p = paste0(varlabel, '; P: ', P))

## -- Create a single faceted plot for all covariate HRs vs reference levels -----------------------
## Change column names to work better in tooltips
names(hrs.mort.inhosp) <- gsub('flevel', 'Comparison', names(hrs.mort.inhosp))
names(hrs.mort.inhosp) <- gsub('lcl', 'Lower.CL', names(hrs.mort.inhosp))
names(hrs.mort.inhosp) <- gsub('ucl', 'Upper.CL', names(hrs.mort.inhosp))
names(hrs.mort.inhosp) <- gsub('effect', 'HR', names(hrs.mort.inhosp))
names(hrs.mort.inhosp) <- gsub('ref.c', 'Reference', names(hrs.mort.inhosp))

gg.mort.inhosp <- ggplot(data = hrs.mort.inhosp,
                         aes(x = Comparison, label = Reference, y = HR)) +
  facet_wrap(~ varlabel.p, ncol = 1, scales = 'free') +
  geom_hline(yintercept = 1, colour = 'grey90', size = 1.25) +
  geom_pointrange(aes(ymin = Lower.CL, ymax = Upper.CL, colour = abs(log(HR)))) +
  scale_color_viridis(direction = -1, end = 0.9, name = 'Effect Size<br>(Log Scale)') +
  scale_x_discrete(name = '') +
  scale_y_continuous(name = ' <br>Hazard Ratios (95% Confidence Intervals), In-Hospital Mortality<br> ',
                     breaks = c(0.25, 0.5, 1, 1.25, 1.5, 2, 4, 8, 16)) +
  guides(fill = FALSE) +
  theme_bw() +
  theme(axis.text = element_text(size = 8))

```

```{r print_mort_inhosp_figures, results = 'asis', fig.width=10, fig.height=75}
gg.mort.inhosp %>%
  ggplotly(tooltip = c("x", "label", "y", "ymin", "ymax"))

```

## Three-Year Mortality among Hospital Survivors
```{r mort_3yr_missing}
## -- How many patients are missing *any* baseline or discharge variables? -------------------------
tbi.oneobs.icu$include.mort.3yr <-
  ifelse(tbi.oneobs.icu$hosp.death == 'Yes', FALSE,
         rowSums(is.na(tbi.oneobs.icu[,c(mortality.baseline.covars, mortality.3yr.covars)])) == 0)
n.exc.mort.3yr <- sum(!subset(tbi.oneobs.icu, mrn %in% pts.inc.survived)$include.mort.3yr)

## MRNs of patients included in mortality models
pts.inc.mort.3yr <- unique(subset(tbi.oneobs.icu, include.mort.3yr)$mrn)

mort.3yr.baseline.missing <-
  as.data.frame(do.call(rbind,
                        lapply(c(mortality.baseline.covars, mortality.3yr.covars),
                               FUN = function(vname){
                                 tmp <- subset(tbi.oneobs.icu, mrn %in% pts.inc.survived)
                                 nmiss <- sum(is.na(tmp[,vname]))
                                 pctall.miss <- round((nmiss / length(pts.inc.survived))*100, 2)
                                 pctexc.miss <- round((nmiss / n.exc.mort.3yr)*100, 0)
                                 c(nmiss, pctall.miss, pctexc.miss)
                               })))
mort.3yr.baseline.missing <- cbind(c(mortality.baseline.covars, mortality.3yr.covars),
                                   mort.3yr.baseline.missing)
names(mort.3yr.baseline.missing) <- c('Covariate',
                                      'N Missing Covariate',
                                      '% Eligible Patients',
                                      '% Excluded Patients')
mort.3yr.baseline.missing <- mort.3yr.baseline.missing[mort.3yr.baseline.missing[,2] > 0,]
rownames(mort.3yr.baseline.missing) <- NULL

## Describe missingness among patient-days included in in-hospital mortality model
mort.3yr.daily.missing <- tbi.daily.icu %>%
  filter(mrn %in% pts.inc.mort.3yr) %>%
  dplyr::select(one_of(mortality.daily.covars)) %>%
  missingInDataFrame() %>%
  filter(nmiss > 0)
rownames(mort.3yr.daily.missing) <- NULL

```

### Patient Inclusion and Missing Data
Out of `r length(pts.inc.survived)` patients who survived their hospital stay and were eligible to
be included in the three-year mortality model, `r n.exc.mort.3yr` are missing one or more baseline
covariates and will be excluded, leaving **`r length(pts.inc.mort.3yr)`** patients included. `r table_nums("mort_3yr_missing_baseline", display = 'cite')` details how many otherwise eligible patients are missing which baseline covariates.

#### `r table_nums("mort_3yr_missing_baseline")`
```{r print_mort_3yr_missing_baseline, results = 'asis'}
pandoc.table(mort.3yr.baseline.missing, justify = c('left', 'right', 'right', 'right'))

```

Among those patients included, we will calculate summary statistics across the entire hospital stay, using multiple imputation to handle patient-days with missing data. `r table_nums("mort_3yr_missing_daily", display = 'cite')` details the percentage
and number of in-hospital patient-days among the `r length(pts.inc.mort.3yr)` patients included
in the three-year mortality model with each variable missing.

#### `r table_nums("mort_3yr_missing_daily")`
```{r print_mort_3yr_missing_daily, results = 'asis'}
pandoc.table(mort.3yr.daily.missing[,c('Variable', '% (N)')], justify = c('left', 'right'))

```

Summary variables will be calculated as follows:

1. Create multiply imputed longitudinal data sets (one record per in-hospital day)
1. Calculate summary statistics (eg, days of delirium) for each patient in data set, separately
1. Use these imputed data sets to run three-year mortality models and combine using usual multiple
imputation procedures

```{r mort_3yr_datamgmt}
## -- Create data sets for 3-year mortality model --------------------------------------------------
## Baseline and discharge information
base.mort.3yr <- tbi.oneobs.icu %>%
  filter(include.mort.3yr) %>%
  dplyr::select(mrn, age, gender, insurance.code, iss, cpr.yn, marshall.comb, pt.cerebral.na,
                disposition.comb, vent.days, los, died.3yr.dc, time.death.3yr.dc)

## Daily data
daily.mort.3yr.org <- tbi.daily.icu %>%
  filter(mrn %in% pts.inc.mort.3yr) %>%
  dplyr::select(mrn, study.day, max.motor.imp, pupil.react.imp, min.glucose.imp, min.hemoglobin.imp,
                min.sodium.imp, mental.status, sofa.mod.nanormal.imp, max.icp.dich, tot.opioid,
                tot.benzo, tot.antipsyc, tot.betablock, tot.propofol, tot.clonid, any.dex,
                any.prbc, any.plasmaplt)

## Combine baseline and daily variables to prep for imputation
basedaily.mort.3yr <- left_join(base.mort.3yr, daily.mort.3yr.org, by = 'mrn')

## Impute daily values
mice.mort.3yr <- mice(basedaily.mort.3yr[,-1], visitSequence = 'monotone')

## Calculate summary statistics by imputation
complete.mort.3yr <- mice::complete(mice.mort.3yr, action = 'long', include = TRUE)

summary.mort.3yr <- complete.mort.3yr %>%
  mutate(mrn = rep(basedaily.mort.3yr$mrn, length(unique(complete.mort.3yr$.imp)))) %>%
  group_by(.imp, mrn) %>%
  summarise(days.motor.lt6 = sum(max.motor.imp < 6),
            days.no.pupil.data = sum(is.na(pupil.react.imp)),
            days.fixed.pupil = ifelse(days.no.pupil.data > 0, NA,
                                      sum(pupil.react.imp %in% c('One reactive', 'Both fixed'))),
            lowest.glucose = min(min.glucose.imp),
            lowest.hemoglobin = min(min.hemoglobin.imp),
            lowest.sodium = min(min.sodium.imp),
            days.del = sum(mental.status == 'Delirious'),
            days.coma = sum(mental.status == 'Comatose'),
            highest.modsofa = max(sofa.mod.nanormal.imp),
            mean.opioid.cube = mean(tot.opioid)^(1/3),
            mean.benzo.cube = mean(tot.benzo)^(1/3),
            mean.antipsyc.cube = mean(tot.antipsyc^(1/3)),
            mean.betablock.cube = mean(tot.betablock)^(1/3),
            mean.propofol.cube = mean(tot.propofol)^(1/3),
            mean.clonid.cube = mean(tot.clonid)^(1/3),
            ever.dex = factor(as.numeric(sum(any.dex == 'Some') > 0),
                              levels = 0:1, labels = c('Never', 'At least some')),
            ever.prbc = factor(as.numeric(sum(any.prbc == 'At least some') > 0),
                               levels = 0:1, labels = c('Never', 'At least once')),
            ever.plasmaplt = factor(as.numeric(sum(any.plasmaplt == 'At least one') > 0),
                                    levels = 0:1, labels = c('Never', 'At least once'))) %>%
  left_join(base.mort.3yr, by = 'mrn') %>%
  as.data.frame()

## Add variable labels
label(summary.mort.3yr$.imp) <- 'Imputation'
label(summary.mort.3yr$mrn) <- 'MRN'
label(summary.mort.3yr$days.motor.lt6) <- 'Days with max motor score <6'
label(summary.mort.3yr$days.no.pupil.data) <- 'Days with no pupil reactivity data'
label(summary.mort.3yr$days.fixed.pupil) <- 'Days with at least one fixed pupil'
label(summary.mort.3yr$lowest.glucose) <- 'Lowest glucose in hospital'
label(summary.mort.3yr$lowest.hemoglobin) <- 'Lowest hemoglobin in hospital'
label(summary.mort.3yr$lowest.sodium) <- 'Lowest sodium in hospital'
label(summary.mort.3yr$days.del) <- 'Days with delirium'
label(summary.mort.3yr$days.coma) <- 'Days with coma'
label(summary.mort.3yr$highest.modsofa) <- 'Highest modified SOFA in hospital'
label(summary.mort.3yr$mean.opioid.cube) <- 'Mean (24h opioids), cube root'
label(summary.mort.3yr$mean.benzo.cube) <- 'Mean (24h benzodiazepines), cube root'
label(summary.mort.3yr$mean.antipsyc.cube) <- 'Mean (24h antipsychotics), cube root'
label(summary.mort.3yr$mean.betablock.cube) <- 'Mean (24h beta-blockers), cube root'
label(summary.mort.3yr$mean.propofol.cube) <- 'Mean (24h propofol), cube root'
label(summary.mort.3yr$mean.clonid.cube) <- 'Mean (24h clonidine), cube root'
label(summary.mort.3yr$ever.dex) <- 'Ever received dexmedetomidine'
label(summary.mort.3yr$ever.prbc) <- 'Ever received PRBC'
label(summary.mort.3yr$ever.plasmaplt) <- 'Ever received plasma, platelets and/or cryo'

## Put summary.mort.3yr back into mids format to use with mice
mids.mort.3yr <- as.mids.update(summary.mort.3yr, .imp = 1, .id = NULL)

## Pull out original summarized data to use as starting data set
withmiss.mort.3yr <- summary.mort.3yr %>% filter(.imp == '0')

## Set datadist
dd.3yr <- datadist(summary.mort.3yr, adjto.cat = 'first')
options(datadist = 'dd.3yr')

```

### Model Covariates
We will include the following covariates in the three-year mortality model (reference levels for
categorical variables are listed first):

- Baseline
    - Age at admission
    - Gender *(`r paste(levels(withmiss.mort.3yr$gender), collapse = '; ')`)*
    - Insurance type *(`r paste(levels(withmiss.mort.3yr$insurance.code), collapse = '; ')`)*
    - Marshall Class equivalent *(`r paste(levels(withmiss.mort.3yr$marshall.comb), collapse = '; ')`)*
    - Cerebral subarachnoid hemorrhage (SAH) *(`r paste(levels(withmiss.mort.3yr$pt.cerebral.na), collapse = '; ')`)*
    - Injurity Severity Score (ISS)
    - CPR *(`r paste(levels(withmiss.mort.3yr$cpr.yn), collapse = '; ')`)*
- In-Hospital
    - Lowest glucose
    - Lowest hemoglobin
    - Lowest sodium
    - Days with motor score < 6
    - Days with at least one fixed pupil
    - Days of delirium
    - Days of coma
    - Highest modified SOFA score (excluding CNS component)
    - Mean (24-hour doses of medications), with the means cube root transformed to mitigate the influence of extremely high values:
        - Opioids (hydromorphone, morphine, hydrocodone, methadone, remifentanil, and fentanyl; converted to fentanyl equivalents); allowed to be nonlinear
        - Benzodiazepines (lorazepam, diazepam, alprazolam, clonazepine, and midazolam; all converted to midazolam equivalents); allowed to be nonlinear
        - Antipsychotics (olanzapine, quetiapine, risperidone, ziprasidone, and haloperidol; all converted to haloperidol equivalents); forced to be linear
        - Beta-blockers (propranolol, labetalol, esmolol, and metoprolol; all converted to metoprolol equivalents); allowed to be nonlinear
        - Propofol; forced to be linear
        - Clonidine; forced to be linear
    - Whether patient ever received:
        - Dexmedetomidine *(`r paste(levels(withmiss.mort.3yr$ever.dex), collapse = '; ')`)*
        - PRBC *(`r paste(levels(withmiss.mort.3yr$ever.prbc), collapse = '; ')`)*
        - Plasma, platelets, and/or cryo *(`r paste(levels(withmiss.mort.3yr$ever.plasmaplt), collapse = '; ')`)*
- Discharge
    - Days on mechanical ventilation
    - Discharge disposition *(`r paste(levels(withmiss.mort.3yr$disposition.comb), collapse = '; ')`)*

Hospital length of stay was also considered, but was strongly related to several other covariates,
and so was not included in the final model since it would likely inflate standard errors without
adding value.

### Redundancy Analysis
To see if any of the covariates in our three-year mortality model are nearly fully explained by the
others, we performed a redundancy analysis on the original (unimputed) summary and baseline data.
Adjusted R^2^ values for each covariate are shown below.

```{r mort_3yr_redun, results = 'markup'}
redun.mort.3yr <- redun(~ age + gender + insurance.code + iss + cpr.yn + marshall.comb +
                          pt.cerebral.na + days.motor.lt6 + days.fixed.pupil + lowest.glucose +
                          lowest.hemoglobin + lowest.sodium + days.del + days.coma +
                          highest.modsofa + mean.opioid.cube + mean.benzo.cube +
                          mean.antipsyc.cube + mean.betablock.cube + mean.propofol.cube +
                          mean.clonid.cube + ever.dex + ever.prbc + ever.plasmaplt +
                          disposition.comb + vent.days + los,
                        data = withmiss.mort.3yr,
                        type = 'adjusted', nk = 4, allcat = TRUE)

highr2.mort.3yr <- which.max(redun.mort.3yr$rsq1)

round(redun.mort.3yr$rsq1, 2)

```

The highest adjusted R^2^ value is `r round(redun.mort.3yr$rsq1[highr2.mort.3yr], 2)` (`r names(redun.mort.3yr$rsq1[highr2.mort.3yr])`). Although there are no variables correlated highly
enough to absolutely be excluded from analysis, there are several strongly related ones. The figure
below shows Spearman correlations among continuous variables from the first imputed data set.

```{r print_mort_3yr_corr, results = 'asis', fig.width=10, fig.height=10}
mort.3yr.corr.data <- summary.mort.3yr %>%
  filter(.imp == '1') %>%
  dplyr::select(-.imp, -mrn, -days.no.pupil.data, -ever.dex, -ever.prbc, -ever.plasmaplt, -gender,
                -insurance.code, -cpr.yn, -marshall.comb, -pt.cerebral.na, -disposition.comb,
                -died.3yr.dc, -time.death.3yr.dc)

corr.mort.3yr <- cor(mort.3yr.corr.data, use = 'pairwise.complete.obs', method = 'spearman')

corrplot.mixed(corr.mort.3yr,
               tl.cex = 0.75, title = 'Three-Year Mortality', tl.col = 'black', mar = c(0, 0, 1, 0))

```


```{r mort_3yr_fitmod}
Surv.mort.3yr <- with(withmiss.mort.3yr, Surv(time = time.death.3yr.dc,
                                              event = as.numeric(died.3yr.dc)))

mod.mort.3yr <- fit.mult.impute(Surv.mort.3yr ~ rcs(age, 4) + gender + insurance.code +
                                  rcs(iss, 4) + cpr.yn + marshall.comb + pt.cerebral.na +
                                  days.motor.lt6 + days.fixed.pupil +
                                  rcs(days.del, 3) + rcs(days.coma, 3) + rcs(highest.modsofa, 4) +
                                  rcs(lowest.glucose, 4) + rcs(lowest.hemoglobin, 4) +
                                  rcs(lowest.sodium, 4) + rcs(mean.opioid.cube, 3) +
                                  rcs(mean.benzo.cube, 3) + mean.antipsyc.cube +
                                  rcs(mean.betablock.cube, 3) + rcs(mean.propofol.cube, 4) +
                                  rcs(mean.clonid.cube, 3) + ever.dex + ever.prbc + ever.plasmaplt +
                                  rcs(vent.days, 3) + disposition.comb,
                                fitter = cph,
                                data = withmiss.mort.3yr,
                                xtrans = mids.mort.3yr,
                                x = TRUE, y = TRUE)

# ## Model using no imputation for ADS abstract
# summary.mort.3yr.noimp <- basedaily.mort.3yr %>%
#   group_by(mrn) %>%
#   summarise(days.motor.lt6 = sum(max.motor.imp < 6),
#             days.no.pupil.data = sum(is.na(pupil.react.imp)),
#             days.fixed.pupil = ifelse(days.no.pupil.data > 0, NA,
#                                       sum(pupil.react.imp %in% c('One reactive', 'Both fixed'))),
#             lowest.glucose = min(min.glucose.imp),
#             lowest.hemoglobin = min(min.hemoglobin.imp),
#             lowest.sodium = min(min.sodium.imp),
#             days.del = sum(mental.status == 'Delirious'),
#             days.coma = sum(mental.status == 'Comatose'),
#             highest.modsofa = max(sofa.mod.nanormal.imp),
#             mean.opioid.cube = mean(tot.opioid)^(1/3),
#             mean.benzo.cube = mean(tot.benzo)^(1/3),
#             mean.antipsyc.cube = mean(tot.antipsyc^(1/3)),
#             mean.betablock.cube = mean(tot.betablock)^(1/3),
#             mean.propofol.cube = mean(tot.propofol)^(1/3),
#             mean.clonid.cube = mean(tot.clonid)^(1/3),
#             ever.dex = factor(as.numeric(sum(any.dex == 'Some') > 0),
#                               levels = 0:1, labels = c('Never', 'At least some')),
#             ever.prbc = factor(as.numeric(sum(any.prbc == 'At least some') > 0),
#                                levels = 0:1, labels = c('Never', 'At least once')),
#             ever.plasmaplt = factor(as.numeric(sum(any.plasmaplt == 'At least one') > 0),
#                                     levels = 0:1, labels = c('Never', 'At least once'))) %>%
#   left_join(base.mort.3yr, by = 'mrn') %>%
#   as.data.frame()
# 
# Surv.mort.3yr.noimp <- with(summary.mort.3yr.noimp, Surv(time = time.death.3yr.dc,
#                                                          event = as.numeric(died.3yr.dc)))
# 
# mod.mort.3yr.noimp <- cph(Surv.mort.3yr.noimp ~ rcs(age, 4) + gender + insurance.code +
#                             rcs(iss, 4) + cpr.yn + marshall.comb + pt.cerebral.na +
#                             days.motor.lt6 + days.fixed.pupil +
#                             rcs(days.del, 3) + rcs(days.coma, 3) + rcs(highest.modsofa, 4) +
#                             rcs(lowest.glucose, 4) + rcs(lowest.hemoglobin, 4) +
#                             rcs(lowest.sodium, 4) + rcs(mean.opioid.cube, 3) +
#                             rcs(mean.benzo.cube, 3) + mean.antipsyc.cube +
#                             rcs(mean.betablock.cube, 3) + rcs(mean.propofol.cube, 4) +
#                             rcs(mean.clonid.cube, 3) + ever.dex + ever.prbc + ever.plasmaplt +
#                             rcs(vent.days, 3) + disposition.comb,
#                           data = summary.mort.3yr.noimp,
#                           x = TRUE, y = TRUE)
# 
# summary(mod.mort.3yr.noimp, days.del, est.all = FALSE)

```

### Model Assumptions

We checked the proportional hazards assumption graphically, looking at the time-dependent coefficient (beta(t)) over time for each model coefficient (code can be shown below).

```{r mort_3yr_checkph, results='hide'}
## -- Check proportional hazard assumption ---------------------------------------------------------
zph.mort.3yr <- cox.zph(mod.mort.3yr, transform = 'log')

par(mfrow = c(1, 2))
plot(zph.mort.3yr, col = 'red', lwd = 2)
abline(v = 0, lty = 2, col = 'gray')
par(mfrow = c(1, 1))

## Text for when figure is included:
# `r figure_nums('mort_inhosp_zph', display = 'cite')` graphically examines the proportional hazards
# assumption (that beta(t) is roughly constant over time; in other words, we want to see flat lines).
# 
# #### `r figure_nums('mort_inhosp_zph')`

```

We do not show the figures here to conserve space, but the proportional hazards
assumption was generally satisfied.

### Model Results
`r table_nums('mort_3yr_results', display = 'cite')` presents a summary of results from the
three-year mortality model. Hazard ratios indicate a comparison between the "comparison" vs the "reference" columns, holding all other covariates at the median or reference category. For example,
a patient who was `r round(dd.3yr$limits$age[3])` years old at the time of injury has about `r round(summary(mod.mort.3yr, age = c(dd.3yr$limits$age[1], dd.3yr$limits$age[3]), est.all = FALSE)[2, 'Effect'], 1)` times the hazard of three-year death at any time point compared to a patient who was `r round(dd.3yr$limits$age[1])` years old, assuming all other covariates are equal. Where possible, the reference and comparison values for continuous variables are the 25th and 75th percentiles, respectively; for variables where these quantities are the same (eg, several drug doses), these values are the minimum and maximum.

**Please note** that while p-values reflect the entire association of each covariate with our
outcome, hazard ratios are only valid for the comparisons listed: For continuous covariates which are allowed to have a nonlinear association with mortality, the hazard ratios depend on the two values we choose; for categorical covariates with more than two categories, the hazard ratios depend on the reference level chosen. More detailed hazard ratios are displayed in `r figure_nums('mort_3yr_figures', display = 'cite')`.

#### `r table_nums('mort_3yr_results')`
```{r mort_3yr_results}
results.mort.3yr <- rms_model_results(mod.mort.3yr,
                                      labeldf = summary.mort.3yr,
                                      printFormat = 'markdown')
names(results.mort.3yr) <- cph.results.headers

```

```{r print_mort_3yr_results, results = 'asis'}
options(width = 200)
pandoc.table(results.mort.3yr, justify = 'lrrrrrr', split.tables = Inf, split.cells = Inf)

```

#### `r figure_nums('mort_3yr_figures')`
For numeric variables, all hazard ratios are for comparison to the median, our best "typical" value;
comparison values are the 10th, 25th, 75th, and 90th percentiles by default, though in some cases
(drug doses, for example), some of these percentiles are the same. For categorical variables, the
reference level is the lefthand level.

```{r mort_3yr_figures}
## -- Get data frame of all HRs for all covariates -------------------------------------------------
## Get all unique variables used in model fit
vars.mort.3yr <- unique(gsub("'+|=.+$", "", names(mod.mort.3yr$coefficients)))

hrs.mort.3yr <- bind_rows(lapply(vars.mort.3yr,
                                 FUN = rms_calc_comparisons,
                                 rmsObj = mod.mort.3yr,
                                 getRatios = TRUE,
                                 df = summary.mort.3yr))

## -- Add variable *labels* ------------------------------------------------------------------------
hrs.mort.3yr.labels <- as.data.frame(do.call(rbind,
                                             lapply(vars.mort.3yr, FUN = function(v){
                                               c('variable' = v,
                                                 'varlabel' = label(summary.mort.3yr[,v]))
                                             })))
hrs.mort.3yr <- hrs.mort.3yr %>%
  left_join(hrs.mort.3yr.labels, by = 'variable') %>%
  left_join(dplyr::select(results.mort.3yr, Covariate, P),
            by = c("varlabel" = "Covariate"))

## -- Create properly ordered factor levels --------------------------------------------------------
hrs.mort.3yr.flevels <-
  ## Get all unique factor levels + whether they are reference
  unique(subset(hrs.mort.3yr, select = c(comp.c, is.ref))) %>%
  ## Create variables by which to order: numeric/NA, then for character, whether reference
  ## (numeric levels will always be ordered by numeric value, regardless of reference)
  mutate(level.num = as.numeric(as.character(comp.c)),
         is.ref.factor = ifelse(!is.na(level.num), FALSE, is.ref)) %>%
  ## Only need original, new reference indicator, and numeric
  dplyr::select(comp.c, is.ref.factor, level.num) %>%
  ## Take only unique: no need for multiple 0 levels, for example
  unique() %>%
  ## Sort all possible levels by 1. numeric values in order, 2. all reference levels,
  ## 3. all other character levels
  arrange(level.num, desc(is.ref.factor)) %>%
  ## Give each unique value a numeric value
  mutate(flevel.num = 1:nrow(.))

## Merge numeric values onto original data set, create final factor variable
hrs.mort.3yr <- hrs.mort.3yr %>%
  left_join(dplyr::select(hrs.mort.3yr.flevels, comp.c, flevel.num),
            by = c('comp.c')) %>%
  mutate(flevel = factor(flevel.num, labels = hrs.mort.3yr.flevels$comp.c),
         varlabel.p = paste0(varlabel, '; P: ', P))

## -- Create a single faceted plot for all covariate HRs vs reference levels -----------------------
## Change column names to work better in tooltips
names(hrs.mort.3yr) <- gsub('flevel', 'Comparison', names(hrs.mort.3yr))
names(hrs.mort.3yr) <- gsub('lcl', 'Lower.CL', names(hrs.mort.3yr))
names(hrs.mort.3yr) <- gsub('ucl', 'Upper.CL', names(hrs.mort.3yr))
names(hrs.mort.3yr) <- gsub('effect', 'HR', names(hrs.mort.3yr))
names(hrs.mort.3yr) <- gsub('ref.c', 'Reference', names(hrs.mort.3yr))

gg.mort.3yr <- ggplot(data = hrs.mort.3yr,
                      aes(x = Comparison, label = Reference, y = HR)) +
  facet_wrap(~ varlabel.p, ncol = 1, scales = 'free') +
  geom_hline(yintercept = 1, colour = 'grey90', size = 1.25) +
  geom_pointrange(aes(ymin = Lower.CL, ymax = Upper.CL, colour = abs(log(HR)))) +
  scale_color_viridis(direction = -1, end = 0.9, name = 'Effect Size<br>(Log Scale)') +
  scale_x_discrete(name = '') +
  scale_y_continuous(name = ' <br>Hazard Ratios (95% Confidence Intervals), Three-Year Mortality<br> ',
                     breaks = c(0.25, 0.5, 1, 1.25, 1.5, 2, 4, 8, 16)) +
  guides(fill = FALSE) +
  theme_bw() +
  theme(axis.text = element_text(size = 8))

```

```{r print_mort_3yr_figures, results = 'asis', fig.width=12, fig.height=95}
gg.mort.3yr %>%
  ggplotly(tooltip = c("x", "label", "y", "ymin", "ymax"))

```

# Delirium Summary Outcomes

---

The following models examine the relationships between a) delirium duration and b)
delirium/coma-free days during the 14 days following hospital admission vs baseline/day of admission
risk factors.

## Model Covariates

Both models will include the following covariates:

- Age at admission
- Gender *(`r paste(levels(tbi.oneobs.icu$gender), collapse = '; ')`)*
- Insurance type *(`r paste(levels(tbi.oneobs.icu$insurance.code), collapse = '; ')`)*
- Marshall Class equivalent *(`r paste(levels(tbi.oneobs.icu$marshall.comb), collapse = '; ')`)*
- Cerebral subarachnoid hemorrhage (SAH) *(`r paste(levels(tbi.oneobs.icu$pt.cerebral.na), collapse = '; ')`)*
- Injurity Severity Score (ISS)
- CPR *(`r paste(levels(tbi.oneobs.icu$cpr.yn), collapse = '; ')`)*
- Maximum motor score, day 0
- Pupil reactivity, day 0 *(`r paste(levels(tbi.oneobs.icu$base.pupil.react.imp), collapse = '; ')`)*
- Minimum glucose, day 0
- Minimum hemoglobin, day 0

## Patient Inclusion and Missing Data

```{r delsummary_missing}
## -- List of baseline and day 1 covariates to include in models for delirium duration, DCFDs ------
delsummary.covars <- c(mortality.baseline.covars, 'base.motor.imp', 'base.pupil.react',
                       'base.glucose.imp', 'base.hemoglobin.imp')

## -- How many patients are missing each covariate and outcome? ------------------------------------
## How many are missing at least one covariate/outcome?
n.delsummary.missany <-
  sum(rowSums(is.na(tbi.oneobs.icu[,c(delsummary.covars, 'days.del.14', 'dcfd.14')])) > 0)

delsummary.missing <-
  as.data.frame(do.call(rbind,
                        lapply(c(delsummary.covars, 'days.del.14', 'dcfd.14'),
                               FUN = function(vname){
                                 nmiss <- sum(is.na(tbi.oneobs.icu[,vname]))
                                 pctall.miss <- round((nmiss / n.included.main)*100, 2)
                                 c(nmiss, pctall.miss)
                               })))
delsummary.missing <- cbind(c(delsummary.covars, 'days.del.14', 'dcfd.14'), delsummary.missing)
names(delsummary.missing) <- c('Variable', 'N Missing Covariate', '% Eligible Patients')
delsummary.missing <- delsummary.missing[delsummary.missing[,2] > 0,]
rownames(delsummary.missing) <- NULL

```

All `r format(n.included.main, big.mark = ',')` patients in the main cohort will be
included in both models; `r n.delsummary.missany` of these (`r round((n.delsummary.missany / n.included.main)*100)`%) are missing one or more baseline covariates and/or delirium summary
outcomes. `r table_nums("delsummary_missing", display = 'cite')` details how many patients in our cohort are missing which covariates or outcomes. This missingness will be handled with multiple imputation.

#### `r table_nums("delsummary_missing")`
```{r print_delsummary_missing, results = 'asis'}
pandoc.table(delsummary.missing, justify = c('left', 'right', 'right'))

```

Delirium outcome and baseline variables will be imputed as follows (similar to our approach for the
three-year mortality model, but with some differences):

1. Create multiply imputed longitudinal data sets (one record per in-hospital day, up to 14 days)
1. Calculate summary statistics (eg, days of delirium) for each patient in data set, separately;
this allows us to use data from days which did have a mental status recorded, but impute for days
which did not
1. Combine original baseline values, present and missing, with these data sets with imputed outcome
values
1. Impute missing baseline values using other baseline covariates and imputed delirium summary
outcomes
1. Use these imputed data sets to run final models

```{r delsummary_datamgmt}
## -- Create data sets for delirium summary models -------------------------------------------------
## Baseline/day 0 information
base.delsummary <- tbi.oneobs.icu %>%
  dplyr::select(mrn, one_of(delsummary.covars), days.del.14, dcfd.14)

## Daily data, for imputing delirium duration/DCFDs
daily.delsummary.org <- tbi.daily.icu %>%
  filter(event %in% paste('Inpatient Day',
                          c('01', '02', '03', '04', '05', '06', '07', '08', '09', 10:14))) %>%
  dplyr::select(mrn, study.day, max.motor.imp, pupil.react.imp, min.glucose.imp, min.hemoglobin.imp,
                min.sodium.imp, mental.status, sofa.mod.nanormal.imp, max.icp.dich, tot.opioid,
                tot.benzo, tot.antipsyc, tot.betablock, tot.propofol, tot.clonid, any.dex,
                any.prbc, any.plasmaplt)

## Combine baseline and daily variables to prep for daily mental status imputation
basedaily.delsummary <- left_join(dplyr::select(base.delsummary, -days.del.14, -dcfd.14),
                                  daily.delsummary.org, by = 'mrn')

## Impute daily values
mice.delsummary.daily <- mice(basedaily.delsummary[,-1], visitSequence = 'monotone')

## Create long data frame of original data + all imputed data sets
complete.delsummary.daily <- mice::complete(mice.delsummary.daily, action = 'long', include = TRUE)

## Add MRN and calculate summary statistics by imputation, patient
summary.delsummary <- complete.delsummary.daily %>%
  ## Do not include original data for now - calculating days.del.14/dcfd.14 won't work the same way
  ## because there's no days.mental
  filter(.imp %in% 1:99) %>%
  mutate(mrn = rep(basedaily.delsummary$mrn, length(unique(complete.delsummary.daily$.imp)) - 1)) %>%
  group_by(.imp, mrn) %>%
  summarise(days.del.14 = sum(mental.status == 'Delirious', na.rm = TRUE),
            dcfd.14 = 14 - sum(mental.status %in% c('Delirious', 'Comatose'), na.rm = TRUE)) %>%
  as.data.frame()

## Add original data - need to add .imp first
delsummary.org <- cbind(factor(rep(0, nrow(base.delsummary))),
                        subset(base.delsummary, select = c(mrn, days.del.14, dcfd.14)))
names(delsummary.org)[1] <- '.imp'

summary.delsummary <- bind_rows(delsummary.org, summary.delsummary)

## Impute baseline variables, using original delirium duration/DCFDs if available
mice.delsummary.base <- mice(base.delsummary[,-1], visitSequence = 'monotone')
complete.delsummary.base <- mice::complete(mice.delsummary.base, action = 'long', include = TRUE)

## Replace versions of delirium outcomes which were imputed *ignoring* partial data with those
## imputed *using* partial data where available
complete.delsummary.base$mrn <- rep(base.delsummary$mrn,
                                    length(unique(complete.delsummary.base$.imp)))

complete.delsummary <- left_join(dplyr::select(complete.delsummary.base, -days.del.14, -dcfd.14),
                                 summary.delsummary,
                                 by = c('.imp', 'mrn')) %>%
  dplyr::select(-.id) %>%
  mutate(.imp = factor(.imp))

## Put complete.delsummary back into mids format to use with mice
mids.delsummary <- as.mids.update(complete.delsummary, .imp = 1, .id = NULL)

## Set datadist
dd.delsummary <- datadist(tbi.oneobs.icu, adjto.cat = 'first')
options(datadist = 'dd.delsummary')

```

## Redundancy Analysis
To see if any of the covariates in our delirium summary models are nearly fully explained by the
others, we performed a redundancy analysis. Adjusted R^2^ values for each covariate are shown below.

```{r delsummary_redun, results = 'markup'}
redun.delsummary <- redun(as.formula(paste('~', paste(delsummary.covars, collapse = ' + '))),
                          data = tbi.oneobs.icu, type = 'adjusted', nk = 4, allcat = TRUE)

highr2.delsummary <- which.max(redun.delsummary$rsq1)

round(redun.delsummary$rsq1, 2)

```

The highest adjusted R^2^ value is `r round(redun.delsummary$rsq1[highr2.delsummary], 2)` (`r names(redun.delsummary$rsq1[highr2.delsummary])`), indicating that there are no redundant variables.
All covariates will be included as specified above.

## Delirium Duration

The distribution of delirium duration over the first 14 days, shown below, follows a negative
binomial distribution; therefore, we will use a negative binomial model with multiple imputation to
look for relationships between it and baseline risk factors.

```{r del_duration_histogram, results = 'asis'}
mjs_plot(tbi.oneobs.icu$days.del.14,
         title = '14-Day Delirium Duration',
         description = 'Histogram of delirium duration within 14 days of hospital admission. Each bar = delirium duration; bar height = counts of patients with that many days of delirium.',
         decimals = 0,
         width = 750, height = 400) %>%
  mjs_histogram(bins = 15) %>%
  mjs_labs(x_label = 'Days of delirium within 14 days of admission',
           y_label = 'Count')

```

```{r deldays_fitmod}
## -- Named vector of model covariates for delirium summary outcomes -------------------------------
delsummary.rhvars <- c("age" = "rcs(age, 3)", "gender" = "gender",
                       "insurance.code" = "insurance.code", "marshall.comb" = "marshall.comb",
                       "pt.cerebral.na" = "pt.cerebral.na", "iss" = "rcs(iss, 3)",
                       "cpr.yn" = "cpr.yn", "base.motor.imp" = "base.motor.imp",
                       "base.pupil.react" = "base.pupil.react",
                       "base.glucose.imp" = "rcs(base.glucose.imp, 3)",
                       "base.hemoglobin.imp" = "rcs(base.hemoglobin.imp, 3)")

## -- Fit models for delirium duration -------------------------------------------------------------
mod.deldays <- with(mids.delsummary, glm.nb(days.del.14 ~ rcs(age, 3) + gender + insurance.code +
                                              marshall.comb + pt.cerebral.na + rcs(iss, 3) + cpr.yn +
                                              base.motor.imp + base.pupil.react +
                                              rcs(base.glucose.imp, 3) +
                                              rcs(base.hemoglobin.imp, 3)))

```

```{r deldays_results}
## -- Get likelihood ratio test info for each term -------------------------------------------------
## Function to flatten lists returned by lrtest_removeTerm() into data.frame with variable name
## included
get_lrtests_deldays <- function(rhvar){
  ## Perform LR test and extract df, X2, and p-value
  lrInfo <- lrtest_removeTerm(orgModel = mod.deldays,
                              removeTerm = delsummary.rhvars[rhvar],
                              miceObjName = 'mids.delsummary')
  
  ## Turn results into a data.frame with variable name added
  tmp <- flatten_dbl(lrInfo) %>%
    t() %>%
    as.data.frame() %>%
    cbind(rhvar, .)
  
  ## Set names
  names(tmp) <- c('covariate', names(lrInfo))
  
  tmp
}

lrtests.deldays <- map(names(delsummary.rhvars), get_lrtests_deldays) %>% bind_rows()

## -- Get IRRs, CIs for each term ------------------------------------------------------------------
## Use calc_nb_ratioci, but turn into data.frame and add variable name to make combining easier
get_irrci_deldays <- function(rhvar){
  tmp <- calc_nb_ratioci(nbObj = mod.deldays, predVar = rhvar, df = tbi.oneobs.icu) %>%
    as.data.frame()
  tmp <- cbind('covariate' = rep(rhvar, nrow(tmp)),
               tmp)

  ## Character versions of ref.val, comp.val:
  ## If covariate is a factor, replace ref.val and comp.val with appropriate levels; otherwise,
  ## just character versions of numerics
  if(inherits(tbi.oneobs.icu[,rhvar], 'factor')){
    tmp$ref.val.c <- levels(tbi.oneobs.icu[,rhvar])[tmp$ref.val]
    tmp$comp.val.c <- levels(tbi.oneobs.icu[,rhvar])[tmp$comp.val]
  } else{
    tmp$ref.val.c <- as.character(round(tmp$ref.val, 2))
    tmp$comp.val.c <- as.character(round(tmp$comp.val, 2))
  }
  
  tmp
}

irrs.deldays <- map(names(delsummary.rhvars), get_irrci_deldays) %>%
  bind_rows() %>%
  group_by(covariate) %>%
  mutate(irr.ci =
           paste0(rndformat(pointest, 2), ' (', rndformat(lcl, 2), ', ', rndformat(ucl, 2), ')'),
         covarRow = 1:n()) %>%
  ungroup()

irrs.deldays$varLabel <- map_chr(irrs.deldays$covariate, ~label(tbi.oneobs.icu[,.]))

## -- Create a row that describes the group test for all nonlinear terms ---------------------------
## -- Actually, this would be a pain; we'd have to create all the NL terms by hand; let's wait -----
## -- and see if someone asks for it ---------------------------------------------------------------

## -- P-value, LR for overall model ----------------------------------------------------------------
## Fit intercept-only model
mod.deldays.null <- with(mids.delsummary, glm.nb(days.del.14 ~ 1))

lrtest.deldays.overall <-
  pool.compare(mod.deldays, mod.deldays.null, data = mids.delsummary, method = 'likelihood')
lrtest.deldays.overall.df <- data.frame(varLabel = '***Overall Model***',
                                        ref.val.c = '',
                                        comp.val.c = '',
                                        irr.ci = '',
                                        df = lrtest.deldays.overall$df1,
                                        Chisq = rndformat(lrtest.deldays.overall$Dm, 2),
                                        P = formatp(lrtest.deldays.overall$pvalue))

## -- Combine IRRs, LR results; add stats for overall model -----------------------------------------
blankRow <- data.frame(varLabel = "", ref.val.c = "", comp.val.c = "", irr.ci = "",
                       df = NA, Chisq = "", P = "")

modstats.deldays <- data.frame(varLabel = c("*Observations*"),
                               ref.val.c = format(nrow(mids.delsummary$data), big.mark = ','))

results.deldays <- irrs.deldays %>%
  left_join(lrtests.deldays, by = 'covariate') %>%
  mutate(varLabel = ifelse(covarRow > 1, "", varLabel),
         Chisq = ifelse(covarRow > 1, "", rndformat(chisq, 2)),
         P = ifelse(covarRow > 1, "", formatp(pvalue))) %>%
  dplyr::select(varLabel, ref.val.c, comp.val.c, irr.ci, df, Chisq, P) %>%
  bind_rows(lrtest.deldays.overall.df) %>%
  bind_rows(blankRow) %>%
  bind_rows(modstats.deldays)

names(results.deldays) <-
  c('Covariate', 'Reference', 'Comparison', 'IRR (95% CI)', 'Chi-square', 'df', 'P')

```

### Model Results
`r table_nums('deldays_results', display = 'cite')` presents a summary of results from the
delirium duration model. Incidence rate ratios indicate a comparison between the "comparison" vs the "reference" columns, holding all other covariates at the median or reference category. For example,
a patient who was `r as.numeric(round(irrs.deldays[1, 'comp.val'], 2))` years old at the time of
injury has about `r as.numeric(round(irrs.deldays[1, 'pointest'], 2))` times the number of delirium
days within the first 14 days after admission as a patient who was `r as.numeric(round(irrs.deldays[1, 'ref.val'], 2))` years old, assuming all other covariates are
equal. The reference and comparison values for continuous variables are the 25th and 75th
percentiles, respectively.

**Please note** that while p-values reflect the entire association of each covariate with our
outcome, incidence rate ratios are only valid for the comparisons listed: For continuous covariates which are allowed to have a nonlinear association with delirium duration, the incidence rate ratios
depend on the two values we choose; for categorical covariates with more than two categories, the ratios depend on the reference level chosen.

#### `r table_nums('deldays_results')`

```{r print_deldays_results, results = 'asis'}
pandoc.table(results.deldays, justify = 'lrrrrrr', style = 'rmarkdown',
             split.tables = 800, missing = "")

```

#### `r figure_nums('deldays_figures')`

We present the number of delirium days within 14 days of admission for each level of each covariate,
adjusted to the median or reference level of all other covariates (our best "typical" value).

```{r deldays_figures_prep}
## -- Create a "baseline" design matrix, adjusted to the median or reference of every covariate ----
## What are rcspline.eval() values for medians of continuous covariates?
get_deldays_median <- function(x){ median(tbi.oneobs.icu[,x], na.rm = TRUE) }
get_deldays_medspline <- function(x){
  knot.locs <- rcspline.eval(tbi.oneobs.icu[,x], nk = 3, knots.only = TRUE)
  x.med <- median(tbi.oneobs.icu[,x], na.rm = TRUE)
  as.numeric(rcspline.eval(x.med, knots = knot.locs))
}

deldays.defaults <- c(1,                                                       ## Intercept
                      get_deldays_median('age'), get_deldays_medspline('age'), ## Age
                      0,                                                       ## Gender
                      0, 0, 0,                                                 ## Insurance.code
                      0, 0, 0,                                                 ## marshall.comb
                      0,                                                       ## pt.cerebral.na
                      get_deldays_median('iss'), get_deldays_medspline('iss'), ## iss
                      0,                                                       ## cpr.yn
                      get_deldays_median('base.motor.imp'),                    ## base.motor.imp
                      0, 0,                                                    ## base.pupil.react
                      get_deldays_median('base.glucose.imp'),                  ## base.glucose.imp
                      get_deldays_medspline('base.glucose.imp'),
                      get_deldays_median('base.hemoglobin.imp'),               ## base.hemoglobin.imp
                      get_deldays_medspline('base.hemoglobin.imp'))
names(deldays.defaults) <- names(pool(mod.deldays)$qbar)

## -- For each covariate, get unique values that we want to adjust to for figures, then create -----
## -- design matrix (nrow = # unique values) that is the same for all other covariates -------------
create_deldays_designmatrix <- function(varName,
                                        xQuantLimits = c(0.05, 0.95),
                                        ## for continuous covariates, how much of the original data
                                        ##  should be included?
                                        defaultVals = deldays.defaults,
                                          ## vector of default values for all coefficients
                                        df = tbi.oneobs.icu){ ## data frame to use for unique values
  
  ## Which coefficients is this variable involved in?
  varInCoefs <- grep(varName, gsub('rcs\\(.*\\)', '', gsub('[0-9]+$', '', names(defaultVals))))
  
  ## For continuous covariates
  if(inherits(df[,varName], c('numeric', 'integer'))){
    ## Get all unique numeric values
    xVals <- sort(unique(df[,varName]))
    
    ## If >20 unique values, restrict to quantiles given
    if(length(xVals) > 20){
      xQuants <- quantile(df[,varName], na.rm = TRUE, probs = xQuantLimits)
      xVals <- xVals[xVals >= xQuants[1] & xVals <= xQuants[2]]
    }
    
    ## If variable is nonlinear, get values for additional columns
    if(length(varInCoefs) > 1){
      ## How many terms are there?
      nNLTerms <- length(grep(paste0(varName, "'{1,99}$"), names(deldays.defaults)))
      
      ## Where are the knots? (uses rcspline.eval and defaults only)
      xKnots <- rcspline.eval(df[,varName], nk = nNLTerms + 2, knots.only = TRUE)
      
      ## Get all covariate values, including original and spline values
      xVals <- rcspline.eval(xVals, knots = xKnots, inclx = TRUE)
    } else{
      ## If variable is linear, put xVals in a matrix with a single column
      xVals <- matrix(xVals, ncol = 1)
    }
    
    ## Also return first column of xVals - could be used for X axis values in figure of
    ## predicted values, eg
    xValues <- xVals[,1]
  } else{
    ## Eventual need: matrix with one row for reference (all coefficients = 0) and one row for each
    ## other category (one coefficient = 1)
    ## Start with square matrix of all 0s
    xVals <- matrix(0, ncol = length(varInCoefs) + 1, nrow = length(varInCoefs) + 1)
    
    ## Set diagonals = 1
    diag(xVals) <- 1
    
    ## Don't need first column; reference value has no coefficient in model
    xVals <- matrix(xVals[,2:ncol(xVals)], ncol = length(varInCoefs))
    
    ## Also return 1:nrow(xVals) - could be matched with levels of varName in figure of
    ## predicted values
    xValues <- 1:nrow(xVals)
  }
  
  ## Add colnames to xVals so that it matches needed columns in defaultVals
  colnames(xVals) <- names(defaultVals)[varInCoefs]
  
  tmp <- matrix(rep(defaultVals, nrow(xVals)), ncol = length(defaultVals), byrow = TRUE)
  colnames(tmp) <- names(defaultVals)
  for(i in 1:ncol(xVals)){
    tmp[,colnames(xVals)[i]] <- xVals[,i]
  }
  
  ## Return final design matrix
  return(list('varName' = varName, 'xLevels' = xValues, 'dmat' = tmp))
}

deldays.designmats <- map(names(delsummary.rhvars), create_deldays_designmatrix)

deldays.predcoefs <- names(pool(mod.deldays)$qbar)
deldays.predcoefs <- deldays.predcoefs[grep("\\(Intercept\\)|'+$", deldays.predcoefs, invert = TRUE)]

## -- Function to get data.frame of predicted counts and add x values ------------------------------
get_deldays_predvals <- function(dmatObj){
  tmp <- calc_nb_counts(nbObj = mod.deldays, designMatrix = dmatObj$dmat)
  tmp <- cbind(dmatObj$xLevels, tmp)
  names(tmp)[1] <- dmatObj$varName
  tmp
}

## -- Get list of data.frames with predicted counts for each covariate -----------------------------
deldays.predvals <- map(deldays.designmats, get_deldays_predvals)
names(deldays.predvals) <- names(delsummary.rhvars)

```

```{r create_deldays_figures}
## -- Function to create a plot for each data.frame: errorbars for plots with <=10 rows, -----------
## -- lines + ribbons for continuous ---------------------------------------------------------------
max.y <- max(bind_rows(deldays.predvals)$count.ucl)

## Short labels to be used in tooltips
tipXLabs <- c("Age", "Gender", "Insurance", "Marshall", "Cerebral SAH", "ISS", "CPR", "Motor Score",
              "Pupil Reactivity", "Glucose", "Hgb")
names(tipXLabs) <- names(deldays.predvals)

create_deldays_figures <- function(df){
  ## Get variable label for plot title
  varLabel <- label(tbi.oneobs.icu[,names(df)[1]])
  
  ## Create tooltip text to be used in "dummy" text aesthetic
  if(inherits(tbi.oneobs.icu[,names(df)[1]], 'factor')){
    df$tipText <- with(df, paste0(tipXLabs[names(df)[1]], ": ",
                                  levels(tbi.oneobs.icu[,names(df)[1]])[df[,1]],
                                  "<br>Count (95% CI): ",
                                  rndformat(count.pe), " (",
                                  rndformat(count.lcl), ", ",
                                  rndformat(count.ucl), ")"))
  } else{
    df$tipText <- with(df, paste0(tipXLabs[names(df)[1]], ": ", df[,1],
                                  "<br>Count (95% CI): ",
                                  rndformat(count.pe), " (",
                                  rndformat(count.lcl), ", ",
                                  rndformat(count.ucl), ")"))
  }
  
  ## If <=10 rows in df, plot using points and errorbars
  if(nrow(df) <= 10){
    p <- ggplot(data = df, aes_string(x = names(df)[1], y = 'count.pe', text = 'tipText')) +
      geom_errorbar(aes(ymin = count.lcl, ymax = count.ucl),
                    width = 0, alpha = 0.5, colour = "#003D79") +
      geom_point(colour = "#003D79") +
      scale_x_continuous(name = NULL,
                         limits = c(0.5, max(df[,1]) + 0.5),
                         breaks = df[,1],
                         labels = levels(tbi.oneobs.icu[,names(df)[1]]))
  } else{
    p <- ggplot(data = df, aes_string(x = names(df)[1], y = 'count.pe')) +
      geom_ribbon(aes(ymin = count.lcl, ymax = count.ucl), alpha = 0.4, fill = "#003D79") +
      geom_line(colour = "#003D79") +
      ## tipText won't show up unless I fake it out like this. weird.
      geom_line(aes(text = tipText), colour = "#003D79")
  }
  p +
    # ggtitle(varLabel) +
    scale_y_continuous(name = 'Adjusted Days of Delirium',
                       limits = c(0, ceiling(max.y)),
                       breaks = seq(0, ceiling(max.y), 1)) +
    theme_minimal() +
    theme(panel.border = element_rect(fill = NA, colour = "grey80"))
}

deldays.ggplots <- map(deldays.predvals, create_deldays_figures)
names(deldays.ggplots) <- names(deldays.predvals)

## -- Function to create plot_ly objects ------------------------------------------------------------
deldays_ggtoplotly <- function(elementNum){
  figTitle <- label(tbi.oneobs.icu[,names(deldays.ggplots)[[elementNum]]])
  
  ggplotly(deldays.ggplots[[elementNum]], tooltip = c("text")) %>%
    layout(showlegend = FALSE,
           annotations = list(xanchor = "left", xref = "paper",
                              yanchor = "bottom", yref = "paper",
                              x = 0, y = 1,
                              text = paste0("<b>", figTitle, "</b>"),
                              font = list(size = 16),
                              showarrow = FALSE),
           xaxis = list(title = ""),
           yaxis = list(title = "Adjusted Days of Delirium"),
           margin = list(b = 20, l = 80, t = 40, r = 20))
}

deldays.plotlys <- map(1:length(deldays.ggplots), deldays_ggtoplotly)

```

```{r deldays_figures, results = 'asis', fig.width=8.5, fig.height=25}
p <- subplot(deldays.plotlys, nrows = 6, shareY = TRUE, margin = 0.02)

p

```


# Software Details

---

`r devtools::session_info()$platform$version` was used for all analyses. `r table_nums('package_info', display = 'cite')` shows all add-on packages loaded.

```{r technical, results = 'asis'}
pander(devtools::session_info()$packages)
```
